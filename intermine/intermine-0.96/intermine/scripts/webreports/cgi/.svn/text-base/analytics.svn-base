#!/usr/bin/perl

use strict;
use warnings;
use Carp;
use Storable;
use File::Basename;
use CGI qw(:standard);
use HTML::Table;
use DateTime;
use XML::Rules;
use LWP::UserAgent;
use SVG::TT::Graph::Line;
use constant APP => 'InterMine-TemplatesAnalytics-0.1';

my $span_units  = param('spanunit') || 'months';
my $span_length = param('spanlen')  || 6;
my $intervals   = param('interval') || 'weeks';


my %config;
while (<DATA>) {
    next unless /=/;
    chomp(my ($k, $v) = split(/\s*=\s*/));
    $config{$k}       = $v;
}

{
    my $auth;
    my $authurl          = 'https://www.google.com/accounts/ClientLogin';
    my $authcontent_type = 'application/x-www-form-urlencoded';
    my $authcontent      = [
			    accountType => 'GOOGLE',
			    Email       => $config{email},
			    Passwd      => $config{psswd},
			    service     => 'analytics',
			    source      => APP,
			   ];
    push @$authcontent, (logintoken   => param('captcha_token'))    if param('captcha_token');
    push @$authcontent, (logincaptcha => param('captcha_response')) if param('captcha_response');

    sub auth {
	return $auth if $auth; # If we are already authorised, we don't need to keep getting tokens

	my $ua = LWP::UserAgent->new();
	$ua->agent(APP);

	my $auth_res = $ua->post($authurl, Content_Type => $authcontent_type, Content => $authcontent);

	if ($auth_res->is_success) {
	    ($auth) = $auth_res->content() =~ /Auth=([\w-]+)/;
	    return $auth;
	}
	else {
	    my ($err) = $auth_res->content() =~ /Error=(\w+)$/m;
	    ### This is what a captcha error looks like 
	    ### (cf. http://code.google.com/apis/accounts/docs/AuthForInstalledApps.html)
	    # Url=http://www.google.com/login/captcha
	    # Error=CaptchaRequired
	    # CaptchaToken=DQAAAGgA...dkI1LK9
	    # CaptchaUrl=Captcha?ctoken=HiteT4b0Bk5Xg18_AcVoP6-yFkHPibe7O9EqxeiI7lUSN
	    if ($err =~ 'CaptchaRequired') {
		my $captcha_url   = $auth_res->content() =~ /CaptchaUrl=(.*)$/m;
		my $captcha_token = $auth_res->content() =~ /Error=(\w+)$/m;
		my $full_url      = "http://www.google.com/accounts/".$captcha_url;
		print(header,
		      start_html('Captcha Authentication Required'),
		      h1('Captcha Authentication'),
		      img({src => $full_url, alt => 'Captcha Image'}),
		      br,
		      start_form,
		      hidden(spanunit  => $span_units),
		      hidden(spanlen   => $span_length),
		      hidden(intervals => $intervals),
		      hidden(display   => param('display')),
		      hidden(captcha_token => $captcha_token),
		      strong('Please enter your response to this Captcha:'),
		      textfield(name => 'captcha_response',
				size => 50),
		      end_form,
		      end_html,
		     );
		exit;
	    }
	    croak "Authentication failed - $err";
	}
    }
}
sub get {
    my $parser = XML::Rules->new(rules => [_default => 'as array']);
    my $ua     = LWP::UserAgent->new();
    $ua->agent(APP);

    my $url    = URI->new(shift);
    my %params = @_;
    $url->query_form(%params);
    my $auth = auth();
    my $res = $ua->get($url, 'GData-Version' => '2', Authorization => "GoogleLogin auth=$auth");
    croak $res->status_line, $url if $res->is_error;
    return $parser->parse($res->content);
}

my $now   = DateTime->now->set_time_zone('Europe/London');;
my $date  = $now->dmy('/');
my $time  = $now->time;
my $earliest_limit = DateTime->new(year => 2005, month => 01, day => 01);


my %error_with;
if ($span_length !~ /^\d+$/m) {
    $span_length = 6;
    push @{$error_with{span_length}}, 'Not a number';
}

my $id = $span_units . $span_length . $intervals . $date; # used to decide if we already have this data

my $data_file   = dirname($ENV{SCRIPT_FILENAME}).'/../cached_data/analytics';
my $data        = eval{retrieve($data_file)} || {};

my $auth;

unless ($data->{$id}) {

    my $start = DateTime->now->subtract($span_units => $span_length);

    my @times = ($now);
    my $no_of_intervals;
    while ($times[-1]->epoch > $start->epoch) {
	push(@times, DateTime->now->subtract($intervals => ++$no_of_intervals));
	if ($earliest_limit->epoch > $times[-1]->epoch) {
	    pop @times;
	    push @{$error_with{span_length}}, 'Too far back - limit is ' . $earliest_limit->dmy('/');
	    last;
	}
    }


    my $feeds_url = 'https://www.google.com/analytics/feeds/accounts/default';
    my $feeds     = get($feeds_url);

    my $table_id;
    for my $entry (@{$feeds->{feed}[0]{entry}}) {
	if ($entry->{title}[0]{_content} eq 'www.flymine.org') {
	    $table_id = $entry->{'dxp:tableId'}[0]{_content}
	}
    }

    my $data_url = 'https://www.google.com/analytics/feeds/data';

    while (@times > 1) {
	my $start = pop @times;
	my %parameters = (
			  ids          => $table_id,
			  dimensions   => 'ga:pagePath',
			  metrics      => 'ga:uniquePageviews',
			  'start-date' => $start->ymd,
			  'end-date'   => $times[-1]->ymd,
			  filters      => 'ga:pagePath=@template.do?name',
			 );

	my $analytics = get($data_url, %parameters);

	my %views_by;
	for my $entry (@{$analytics->{feed}[0]{entry}}) {
	    my $p = $entry->{'dxp:dimension'}[0]{value};
	    if ($p =~ /template\.do/) {
		$p =~ s/.*template\.do\?name=([^&]+).*/$1/;
		my $v = $entry->{'dxp:metric'}[0]{value};
		$views_by{$p} = $v;
	    }
	}
	my $key = $start->ymd . ' to ' . $times[-1]->ymd;
	$data->{$id}{$key} = \%views_by;
    }
    store($data, $data_file);
}

my $results = $data->{$id};
my @dates   = sort keys %$results;

if (param('display') eq 'as graph') {
    my %line_names;
    for my $d (@dates) {
	$line_names{$_}++ for (keys %{$results->{$d}});
    }
    my %line_for;
    for my $ln (keys %line_names) {
	for my $d (@dates) {
	    push(@{$line_for{$ln}}, $results->{$d}{$ln} || 0);
	}
    }

    my $graph = SVG::TT::Graph::Line->new({
					   'height' => '2000',
					   'width'  => '2000',
					   'fields' => \@dates,
					   area_fill => 0,
					   rotate_x_labels => 1,
					   random_colors => 1,
					   scale_integers => 1,
					   key => 1,
					   tidy => 0,
					  });
    $graph->compress(0);
    for (keys %line_names) {
	$graph->add_data({
			  'data'  => \@{$line_for{$_}},
			  'title' => $_,
			 });
    }
    print header('image/svg+xml'), $graph->burn;
}
else {
    my $interval  = ucfirst(substr($intervals, 0, -1));
    my $title     = 'Template Analytics';
    print(
	  header,
	  start_html( -title => $title,
		      -style =>{src => '/css/style.css'}),
	  div({id => 'heading'},
	      div({id => 'banner'}, h1($title)),
	      img({
		   id => 'logo',
		   src => '/chrome/intermine_logo.png',
		   alt => 'Logo',
		   width => 100,
		   height => 100,
		  }),
	      div({class => 'clearall'}, ''),
	     ),
	  div({id => 'content'},
	      div({id => 'menu'},
		  ul(li({-type => 'disc'},
			[
			 a({-href => '/webreports'}, 'All Reports'),
			 a({-href => '/webreports/analytics'}, 'Google Analytics for Templates'),
			 a({-href => '/webreports/models'},    'Model Comparison'),
			 a({-href => '/webreports/templates'}, 'Template Collection Comparison'),
			]
		       )
		    ),
		 ),
	      br,
	      p({align => 'right'},
		small(i("Automatically generated on $date at $time"))
	       ),
	      div({class => 'clearall'}),
	      start_form,
	      "Go back",
	      textfield(
			'spanlen',
			6,
			10,
			10,
		       ),
	      popup_menu(
			 'spanunit',
			 [
			  'years',
			  'months',
			  'weeks',
			  'days',
			 ],
			 'months',
			),
	      "and show data by",
	      popup_menu(
			 'interval',
			 [
			  'years',
			  'months',
			  'weeks',
			  'days',
			 ],
			 'weeks',
			),
	      popup_menu(
			 'display',
			 [
			  'as tables',
			  'as graph',
			 ],
			),
	      submit,
	      end_form,
	     ),
	 );
    for my $key (keys %error_with) {
	for my $error (@{$error_with{$key}}) {
	    print p(strong({style => 'color:red'}, "Problem with $key:", $error));
	}
    }
    my (@used_dates, $i);
    while (my $date = shift @dates) {
	my $table = HTML::Table->new( -class => 'list',
				      -oddrowclass => 'odd');
	$table->addRow(strong('Template Name'), 'Unique Pageviews');
	$table->setRowBGColor('-1', 'Orange');
	for my $path (sort {$results->{$date}{$b} <=> $results->{$date}{$a}} keys %{$results->{$date}}) {
	    $table->addRow($path, strong($results->{$date}{$path}));
	}
	my $rows = $table->getTableRows;
	print h2(a({-name => $date}, $interval, ++$i, ": $date"));
	my @links;
	push @links, a({-href => '#'.$used_dates[-1]},'<< previous')
	    if  @used_dates;
	push @links, a({-href => '#'.$dates[0]},      'next >>')
	    if  @dates;
	print(
	      div({id => 'menu'},ul(li([@links]))),
	      div({class => 'clearall'}),
	     );
	print $table;
	push @used_dates, $date;
    }
    print end_html;
}
exit;
__DATA__
email = flymine.org@googlemail.com
psswd = integrate
