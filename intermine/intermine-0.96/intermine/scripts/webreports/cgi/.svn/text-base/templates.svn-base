#!/usr/bin/perl

use strict;
use warnings;
use Carp;
use Storable;
use DateTime;
use File::Basename;
use constant APP => 'InterMine-TemplateComparer-0.1';

use HTML::Table;
use CGI qw(:standard);
use LWP::Simple qw(get);

use List::MoreUtils qw(uniq zip);

use Webservice::InterMine;
use Webservice::InterMine::Service;

$Storable::Deparse = 1;
$Storable::Eval = 1;

my ($changed, %link_to, %version_of, @services);

my $data_file   = dirname($ENV{SCRIPT_FILENAME}).'/../cached_data/templates';
my $data        = eval{retrieve($data_file)} || {};

my $order = sub {lc($a) cmp lc($b)};

#The two different methods used in an analysis, and things that change depending on them
my @wanted_values = ('all_constraints', 'views', 'editable_constraints');
my @wanted_labels = ('All Constraints', 'Views', 'Editable Constraints');
my %label_hash    = zip(@wanted_values, @wanted_labels);
my @column_headers = ('All Constraints', 'View Columns', 'Editable Constraints');
my %col_header_for = zip(@wanted_values, @column_headers);

my $wanted = 
    (param('submitted'))
    ? param('wanted')   # User's choice
    : $wanted_values[0]; # default starting state

sub make_table_from_rows {
    my ($rows_ref, $row_order) = @_;
    my @rows = @$rows_ref;
    my @columns = ($row_order)
	          ? @$row_order
                  : sort($order keys %{$rows[0]});
    if (param('only_differences')) {
	@rows = grep {uniq(@{$_}{@columns[1 .. $#columns]}) > 1} @rows;
	return '' unless @rows;
    }
    my $table = HTML::Table->new( -rows  => (@rows + 1), 
                                  -cols => scalar(@columns),
                                  -class => 'list',
                                  -oddrowclass => 'odd');
    for my $col (1 .. @columns) {
	# Set headers
	$table->setCell(1, $col, strong($columns[$col -1]) );
	$table->setCellBGColor(1, $col, 'DarkGray');
	# Fill body
	for my $row (2 .. @rows + 1) {
	    my $content = $rows[$row - 2]->{$columns[$col -1]};
	    $table->setCell($row, $col, $content);
	    if ($col == 1) {
		$table->setCellBGColor($row, $col, 'DarkSalmon') if ($content =~ /color:red/);
	    }
	}
    }
    for my $row (2 .. @rows + 1) {
	my $colour;
	if (uniq(grep {$_ ne 'NO'} map {$table->getCell($row, $_)} (2 .. @columns)) > 1) {
	    $colour = 'orange';
	}
	else {
	    $colour = 'YellowGreen';
	}
	for my $col (2 .. @columns) {
	    $table->setCellBGColor(
		$row, $col,
		(($table->getCell($row, $col) eq 'NO') ? 'OrangeRed' : $colour),
		);
	}
    }
    return $table;
}

while (<DATA>) {
    chomp;
    next unless /^http/;
    my ($service_name) = /([a-z]+mine)/;
    ($service_name) = /intermine\.(\w+)/ if ($service_name eq 'intermine');
    push @services, $service_name;
    $link_to{$service_name}       = $_;
    my $service = Webservice::InterMine->get_service($_ . '/service');
    $version_of{$service_name}    = $service->release;
    next unless ($version_of{$service_name});
    next if ($data->{version_of}{$service_name} eq $version_of{$service_name}
        and defined $data->{service_from}{$service_name});
    next if ((param('submitted')) and (not param($service_name)));
    $data->{service_from}{$service_name} = $service;
    $data->{version_of}{$service_name} = $version_of{$service_name};
    $changed++;
}

### Write Service table
my %active = map 
    {($_ => (param('submitted'))
            ? defined param($_)
            : 1)}
    @services;
@services = grep {$active{$_}} @services;

my $service_table = HTML::Table->new();
while (my ($service, $url) = each %link_to) {
    $service_table->addRow(
 	checkbox(-name    => $service,
		 -checked => $active{$service},
		 -value   => 'ON',
		 -label   => '',
	),
	strong(a({-href => $url},$service)),
	"Version: $version_of{$service}");
}

my $data_key = join('', @services, $wanted);

my (@templates, %want, %problems_with);
# Parse the template for date, unless that's been done already
unless (exists $data->{$data_key}) {
    for my $service (@services) {
        warn "getting templates for $service";
        for my $template ($data->{service_from}->{$service}->get_templates) {
            push @templates, (my $name = $template->name);
            for my $w (map {(ref $_)?$_->to_string:$_} $template->$wanted) {
                $want{$service}{$name}{$w}++;
                $want{$name}{$w}++;
            }
        }
    }
    $data->{$data_key} = {
            templates  => [uniq sort($order @templates)],
            want       => {%want},
            problems   => {%problems_with},
            };
    $changed++;
} else {
    @templates     = @{$data->{$data_key}{templates}};
    %want          = %{$data->{$data_key}{want}};
    %problems_with = %{$data->{$data_key}{problems}};
}

#store($data, $data_file) if $changed;

### Write main table
my @rows = map { {Template => $_} } uniq(sort {$a cmp $b} @templates);
for my $row (@rows) {
    my $name = $row->{Template};
    for my $service (@services) {
	$row->{$service} = (exists $want{$service}{$name})
	                   ? scalar(keys %{$want{$service}{$name}})
                           : 'NO';
    }
    # Set internal Anchors
    my $problem_str = ($problems_with{$name}) ? join(', ', map {'"'.$_.'"'} @{$problems_with{$name}}) : undef;
    my @style  = ($problem_str) ? (style => 'color:red') : ();
    my @values = @{$row}{@services};

    # If more than one value is non-'NO' (ie, there is something to compare)
    # And they aren't all '0'
    # Or if there is a problem to report
#    if ( ((grep({$_ ne 'NO'} @values) > 1) and (grep({$_ eq '0'} @values) != @values)) or ($problem_str) ) {
	$row->{Template} = strong(a({
				     href  => '#'.$name,
				     title => $problem_str,
				     @style,
				    },
				    $name));
#    }
}
unshift @rows, {map {($_ => scalar(keys %{$want{$_}}) || 'Total')} (Template => @services)}; # header row
my $row_order = ['Template', sort($order grep {$_ ne 'Template'} keys %{$rows[0]})];
my $model_class_table = make_table_from_rows(\@rows, $row_order);

### Write tables analysing individual templates
my @template_tables;
my $col1_name = $col_header_for{$wanted};
for my $template_name (@templates) {
    my @rows  = map { {$col1_name => $_} } sort($order keys %{$want{$template_name}});
    next unless @rows;
    for my $row (@rows) {
	for my $service (@services) {
	    $row->{$service} = (exists $want{$service}{$template_name}{$row->{$col1_name}})
		        ? 'YES'
			    : 'NO';
	}
    }
    my $row_order      = [$col1_name, sort($order grep {$_ ne $col1_name} keys %{$rows[0]})];
    my $template_table = make_table_from_rows(\@rows, $row_order);
    push (@template_tables, {name => $template_name, tbl => $template_table}) if $template_table;
}



my $now   = DateTime->now->set_time_zone('Europe/London');
my $date =  $now->dmy('/');
my $time =  $now->time;
my $title = 'Template Comparison';

my $main_table_link = a({-href => '#maintable'}, 'main table');
my $sub_table_link  = a({-href => '#subtables'}, 'sub-table');
my $table = HTML::Table->new( -rows  => 1, 
                            -cols => 2,
                            -class => 'list',
                            -oddrowclass => 'odd');
$table->setCell(1, 1, 
radio_group(
        -name      => 'wanted',
        -values    => \@wanted_values,
        -default   => 'get_all_constraints',
        -linebreak => 1,
        -labels    => \%label_hash,
        ) .
checkbox(
    -name    => 'only_differences',
    -checked => 0,
    -value   => 'ON',
    -label   => 'Hide rows without differences',
    ),
);
$table->setCell(1, 2,
	  $service_table,
);
print(
      header,
      start_html( -title => $title,
		  -style =>{src => '/css/style.css'}),
      div({id => 'heading'},
	  div({id => 'banner'}, h1($title)),
	  img({
	       id => 'logo',
	       src => '/chrome/intermine_logo.png',
	       alt => 'Logo',
	       width => 600,
	       height => 75,
	      }),
	  div({class => 'clearall'}, ''),
	 ),
      div({id => 'content'},
	  div({id => 'menu'},
	      ul(li({-type => 'disc'},
		    [
		     a({-href => '/webreports'}, 'All Reports'),
#		     a({-href => '/webreports/analytics'}, 'Google Analytics for Templates'),
		     a({-href => '/webreports/models'},    'Model Comparison'),
		     a({-href => '/webreports/templates'}, 'Template Collection Comparison'),
		    ]
		   )
		),
	     ),
	  br,
	  p({align => 'right'}, small(i("Automatically generated on $date at $time"))),
	  p(<<'ENDQUOTE'),
This page has several tables to compare the templates used by different InterMine implementations. These templates were fetched from the respective webservices, and then analysed to create these tables. You can select which mines you would like to compare by using the checkboxes next to their names.
ENDQUOTE
	  p(<<"ENDQUOTE"),
The $main_table_link lists which templates are available from which mines. Where the template is absent, the word "NO" appears in a red box. If the template is present, then either the number of constraints declared in that template, or the number of columns in the output (the "view"), will appear in the cell, depending on the option selected. If the mines with this template all have a template with the same number of constraints or view-columns, then those mine's cells are green. If there is a difference in the number of constraints/view columns, then the cell is coloured orange. To filter out the uninteresting rows (ie. the ones where all the values are the same), you can choose to "hide rows without differences".
ENDQUOTE
	  p(<<"ENDQUOTE"),
To further investigate templates with differences you can click on the template name, which is a link that will take you to a $sub_table_link, showing which constraints are present or absent in a particular model. Only templates that are present in more than one model, and where at least one model declares constraints in that template, will have a sub-table, and thus a link. If a template is invalid in one of the mines, it will be highlighted in red, and holding the mouse over its name will bring up a box with a list of the specific problems with the template, preprepended with the mine in which the template is broken. This list of problems can also be viewed by visiting the individual table for this template.
ENDQUOTE
	  start_form,
	  br,
	  strong('Analyse differences in'),
	  br,
      $table,
	  submit('submitted', 'reanalyse'),
	  end_form,
	 ),
     );

if (@services) {
    print 
	h2(a({-name => 'maintable'}, $label_hash{$wanted} . ' of Templates By Service')),
	$model_class_table,
	br,
	h2(a({-name => 'subtables'}, $label_hash{$wanted} . ' of Individual Templates By Model'));

    for my $table (@template_tables) {
    	print h2(a({-name => $table->{name}}, $table->{name}));
	if ($problems_with{$table->{name}}) {
	    print p(strong({style => 'color:red'}, join(', ', @{$problems_with{$table->{name}}})));
	}
    	print $table->{tbl};
    }
}
else {
    print 
	h2('No services selected - please select a service');
}
print end_html;

__DATA__
http://dough.stanford.edu:8080/yeastmine-dev
#http://ratmine.mcw.edu/ratmine
http://preview.flymine.org/preview
http://intermine.modencode.org/query
http://zmine.cs.uoregon.edu:8080/dev-zfinmine
